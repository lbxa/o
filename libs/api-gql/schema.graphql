schema {
  query: Query
  mutation: Mutation
}

input AuthCreateUserInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
}

type AuthCreateUserPayload {
  tokens: Tokens!
  user: User!
}

input AuthLoginInput {
  email: String!
  password: String!
}

"""Login payload"""
type AuthLoginPayload {
  """Access to the refresh tokens"""
  tokens: Tokens!
  """The user that has been logged in"""
  user: User!
}

type Challenge implements Node & Timestamps {
  activity: ChallengeActivity!
  activityTopMovers(challengeId: ID): [ChallengeActivityResult!]
  activityTopResults(challengeId: ID): [ChallengeActivityResult!]
  cadence: ChallengeCadence
  community: Community
  createdAt: DateTime
  description: String
  endDate: DateTime
  id: ID!
  invitations: [ChallengeInvitation!]
  members: [User!]
  memberships: [ChallengeMembership!]
  mode: ChallengeMode
  name: String!
  startDate: DateTime
  updatedAt: DateTime
}

type ChallengeActivity implements Node & Timestamps {
  challengeId: ID
  createdAt: DateTime
  goal: ChallengeActivityGoal!
  id: ID!
  measurement: ChallengeActivityMeasurement!
  target: Int
  type: ChallengeActivityType!
  unit: ChallengeActivityUnits!
  updatedAt: DateTime
}

input ChallengeActivityCreateInput {
  goal: ChallengeActivityGoal!
  measurement: ChallengeActivityMeasurement!
  target: Int
  type: ChallengeActivityType!
  unit: ChallengeActivityUnits!
}

enum ChallengeActivityGoal {
  HIGHEST_NUMBER
  LONGEST_TIME
  LOWEST_NUMBER
  MOST_IMPROVED
  SHORTEST_TIME
  SPECIFIC_TARGET
}

enum ChallengeActivityMeasurement {
  COUNTING
  DURATION
  IMPROVEMENT
}

"""
Results for a challenge activity are recorded per user per activity.
In the future we may want to support multiple activities per challenge.

There can be multiple results per activity per user.
"""
type ChallengeActivityResult implements Node & Timestamps {
  activity: ChallengeActivity!
  createdAt: DateTime
  id: ID!
  result: Int!
  updatedAt: DateTime
  user: User!
}

input ChallengeActivityResultCreateInput {
  activityId: ID!
  challengeId: ID!
  result: Int!
  userId: ID!
}

enum ChallengeActivityType {
  DISTANCE
  REPETITIONS
  SOCIAL
  TIME_BASED
  WEIGHTLIFTING
}

enum ChallengeActivityUnits {
  FEET
  HOURS
  KILOGRAMS
  KILOMETRES
  METRES
  MILES
  MINUTES
  NONE
  PERCENT
  POUNDS
  SECONDS
}

enum ChallengeCadence {
  BIWEEKLY
  DAILY
  MONTHLY
  NONE
  WEEKLY
  YEARLY
}

input ChallengeCreateInput {
  cadence: ChallengeCadence!
  communityId: ID!
  description: String!
  endDate: DateTime!
  mode: ChallengeMode!
  name: String!
  startDate: DateTime!
}

type ChallengeInvitation implements Node & Timestamps {
  challenge: Challenge!
  createdAt: DateTime
  expiresAt: DateTime!
  id: ID!
  invitee: User!
  inviter: User!
  status: InvitationStatus!
  updatedAt: DateTime
}

type ChallengeMembership implements Node {
  challenge: Challenge!
  community: Community!
  id: ID!
  joinedAt: DateTime!
  user: User!
}

enum ChallengeMode {
  BLIND_TRUST
  BUDDY_SYSTEM
  VERIFIED_ONLY
}

input ChallengeUpdateInput {
  description: String
  endDate: DateTime
  id: ID!
  name: String
  startDate: DateTime
}

type Community implements Node & Timestamps {
  challenges: [Challenge!]
  createdAt: DateTime
  id: ID!
  invitations: [CommunityInvitation!]
  isPublic: Boolean
  isVerified: Boolean
  members: [User!]
  memberships: [CommunityMembership!]
  name: String!
  updatedAt: DateTime
  users: [User]
}

input CommunityCreateInput {
  isPublic: Boolean!
  name: String!
}

type CommunityInvitation implements Node & Timestamps {
  community: Community!
  createdAt: DateTime!
  expiresAt: DateTime!
  id: ID!
  invitee: User!
  inviter: User!
  status: InvitationStatus!
  updatedAt: DateTime
}

type CommunityMembership implements Node {
  community: Community!
  id: ID!
  isAdmin: Boolean!
  joinedAt: DateTime!
  user: User!
}

input CommunityUpdateInput {
  id: ID!
  name: String
}

"""Date custom scalar type"""
scalar DateTime

enum InvitationStatus {
  ACCEPTED
  DECLINED
  PENDING
}

type Mutation {
  """Create a new user"""
  authCreateUser(authCreateUserInput: AuthCreateUserInput!): AuthCreateUserPayload!
  """Login to the application"""
  authLogin(authLoginInput: AuthLoginInput!): AuthLoginPayload!
  """Logout from the application"""
  authLogout(id: Int!): Boolean!
  """Refresh the access and refresh tokens"""
  authRefreshTokens: Tokens!
  challengeActivityResultCreate(challengeActivityResultCreateInput: ChallengeActivityResultCreateInput!): ChallengeActivityResult!
  challengeCreate(challengeActivityCreateInput: ChallengeActivityCreateInput!, challengeCreateInput: ChallengeCreateInput!): Challenge!
  challengeDelete(id: ID!): Boolean!
  challengeInvite(challengeId: ID!, userId: ID!): Boolean!
  challengeJoin(inviteId: ID!): Challenge!
  challengeLeave(id: ID!): Boolean!
  challengeUpdate(challengeUpdateInput: ChallengeUpdateInput!): Challenge!
  communityCreate(communityCreateInput: CommunityCreateInput!): Community!
  communityDelete(id: ID!): Boolean!
  communityInvite(communityId: ID!, userId: ID!): Boolean!
  communityJoin(inviteId: Int!): Community!
  communityLeave(id: ID!): Boolean!
  communityUpdate(communityUpdateInput: CommunityUpdateInput!): Community!
  """Update a user"""
  userUpdate(userUpdateInput: UserUpdateInput!): User!
}

interface Node {
  id: ID!
}

type Query {
  challenge(id: ID!): Challenge
  challengeActivityResults(challengeId: ID!): [ChallengeActivityResult!]
  challengeActivityTopResults(challengeId: ID!): [ChallengeActivityResult!]
  challengeInvitations(userId: ID!): [ChallengeInvitation!]
  challenges: [Challenge!]
  communities: [Community!]
  community(id: ID!): Community
  communityChallenges(communityId: ID!): [Challenge!]
  communityInvitations(userId: ID!): [Community!]
  health: String!
  node(id: ID!): Node
  userChallenges(userId: ID!): [Challenge!]
  userCommunities(userId: ID!): [Community!]
  """Search for users by name"""
  userSearch(searchTerm: String): [User!]
  """Validate if an email is already taken"""
  userValidateEmail(email: String!): ValidEmailResponse!
  """All users"""
  users: [User!]
  viewer: Viewer
}

interface Timestamps {
  createdAt: DateTime
  updatedAt: DateTime
}

"""Tokens are the access and refresh tokens for the user"""
type Tokens {
  """Access tokens expire more frequently for stronger security measures"""
  accessToken: String!
  """Refresh token is stored safely for user to refresh access token"""
  refreshToken: String!
}

"""A user of the app"""
type User implements Node & Timestamps {
  communities: [Community!]
  createdAt: DateTime
  email: String
  firstName: String
  """If they have any..."""
  friends: [User!]
  handle: String
  id: ID!
  lastName: String
  memberships: [CommunityMembership!]
  password: String
  receivedInvitations: [CommunityInvitation!]
  searchFriends(searchTerm: String): [User!]
  sentInvitations: [CommunityInvitation!]
  updatedAt: DateTime
}

input UserUpdateInput {
  email: String
  firstName: String
  handle: String
  id: ID!
  lastName: String
}

type ValidEmailResponse {
  alreadyTaken: Boolean!
}

type Viewer {
  challenge(challengeId: ID!): Challenge
  challenges(communityId: ID!): [Challenge!]
  communities: [Community!]
  user: User
}