input AuthLoginInput {
  email: String!
  password: String!
}

"""Tokens are the access and refresh tokens for the user"""
type Tokens {
  """Access tokens expire more frequently for stronger security measures"""
  accessToken: String!

  """Refresh token is stored safely for user to refresh access token"""
  refreshToken: String!
}

"""Login payload"""
type AuthLoginPayload {
  """Access to the refresh tokens"""
  tokens: Tokens!

  """The user that has been logged in"""
  user: User!
}

input AuthCreateUserInput {
  firstName: String!
  lastName: String!
  email: String!
  password: String!
}

type AuthCreateUserPayload {
  tokens: Tokens!
  user: User!
}

type Mutation {
  """Login to the application"""
  authLogin(authLoginInput: AuthLoginInput!): AuthLoginPayload!

  """Logout from the application"""
  authLogout(id: Int!): Boolean!

  """Create a new user"""
  authCreateUser(authCreateUserInput: AuthCreateUserInput!): AuthCreateUserPayload!

  """Refresh the access and refresh tokens"""
  authRefreshTokens: Tokens!
  challengeActivityResultCreate(challengeActivityResultCreateInput: ChallengeActivityResultCreateInput!): ChallengeActivityResult!
  challengeCreate(challengeCreateInput: ChallengeCreateInput!, challengeActivityCreateInput: ChallengeActivityCreateInput!): Challenge!
  challengeUpdate(challengeUpdateInput: ChallengeUpdateInput!): Challenge!
  challengeDelete(id: ID!): Boolean!
  challengeInvite(userId: ID!, challengeId: ID!): Boolean!
  challengeJoin(inviteId: ID!): Challenge!
  challengeLeave(id: ID!): Boolean!
  communityCreate(communityCreateInput: CommunityCreateInput!): Community!
  communityUpdate(communityUpdateInput: CommunityUpdateInput!): Community!
  communityDelete(id: ID!): Boolean!
  communityInvite(userId: ID!, communityId: ID!): Boolean!
  communityJoin(inviteId: Int!): Community!
  communityLeave(id: ID!): Boolean!

  """Update a user"""
  userUpdate(userUpdateInput: UserUpdateInput!): User!
}

"""
Results for a challenge activity are recorded per user per activity.
In the future we may want to support multiple activities per challenge.

There can be multiple results per activity per user.
"""
type ChallengeActivityResult implements Node & Timestamps {
  id: ID!
  user: User!
  activity: ChallengeActivity!
  result: Int!
  createdAt: DateTime
  updatedAt: DateTime
}

input ChallengeActivityResultCreateInput {
  challengeId: ID!
  activityId: ID!
  userId: ID!
  result: Int!
}

type Challenge implements Node & Timestamps {
  activityTopResults(challengeId: ID): [ChallengeActivityResult!]
  activityTopMovers(challengeId: ID): [ChallengeActivityResult!]
  id: ID!
  name: String!
  description: String
  community: Community
  startDate: DateTime
  endDate: DateTime
  mode: ChallengeMode
  cadence: ChallengeCadence
  createdAt: DateTime
  updatedAt: DateTime
  activity: ChallengeActivity!
  members: [User!]
  memberships: [ChallengeMembership!]
  invitations: [ChallengeInvitation!]
}

type Query {
  challengeActivityResults(challengeId: ID!): [ChallengeActivityResult!]
  challengeActivityTopResults(challengeId: ID!): [ChallengeActivityResult!]
  challenge(id: ID!): Challenge
  challenges: [Challenge!]
  communityChallenges(communityId: ID!): [Challenge!]
  userChallenges(userId: ID!): [Challenge!]
  challengeInvitations(userId: ID!): [ChallengeInvitation!]
  community(id: ID!): Community
  communities: [Community!]
  communityInvitations(userId: ID!): [Community!]
  health: String!
  node(id: ID!): Node

  """All users"""
  users: [User!]

  """Validate if an email is already taken"""
  userValidateEmail(email: String!): ValidEmailResponse!

  """Search for users by name"""
  userSearch(searchTerm: String): [User!]
  viewer: Viewer
}

enum ChallengeActivityType {
  REPETITIONS
  WEIGHTLIFTING
  TIME_BASED
  DISTANCE
  SOCIAL
}

enum ChallengeActivityUnits {
  KILOGRAMS
  POUNDS
  METRES
  FEET
  SECONDS
  MINUTES
  HOURS
  MILES
  KILOMETRES
  PERCENT
  NONE
}

enum ChallengeActivityMeasurement {
  COUNTING
  DURATION
  IMPROVEMENT
}

enum ChallengeActivityGoal {
  LOWEST_NUMBER
  HIGHEST_NUMBER
  SPECIFIC_TARGET
  SHORTEST_TIME
  LONGEST_TIME
  MOST_IMPROVED
}

type ChallengeActivity implements Node & Timestamps {
  id: ID!
  challengeId: ID
  type: ChallengeActivityType!
  measurement: ChallengeActivityMeasurement!
  goal: ChallengeActivityGoal!
  target: Int
  unit: ChallengeActivityUnits!
  createdAt: DateTime
  updatedAt: DateTime
}

input ChallengeActivityCreateInput {
  type: ChallengeActivityType!
  measurement: ChallengeActivityMeasurement!
  goal: ChallengeActivityGoal!
  target: Int
  unit: ChallengeActivityUnits!
}

enum ChallengeMode {
  BLIND_TRUST
  BUDDY_SYSTEM
  VERIFIED_ONLY
}

enum ChallengeCadence {
  NONE
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  YEARLY
}

type ChallengeMembership implements Node {
  id: ID!
  user: User!
  community: Community!
  challenge: Challenge!
  joinedAt: DateTime!
}

type ChallengeInvitation implements Node & Timestamps {
  id: ID!
  challenge: Challenge!
  inviter: User!
  invitee: User!
  status: InvitationStatus!
  createdAt: DateTime
  updatedAt: DateTime
  expiresAt: DateTime!
}

input ChallengeCreateInput {
  name: String!
  description: String!
  communityId: ID!
  startDate: DateTime!
  endDate: DateTime!
  mode: ChallengeMode!
  cadence: ChallengeCadence!
}

input ChallengeUpdateInput {
  id: ID!
  name: String
  description: String
  startDate: DateTime
  endDate: DateTime
}

type Community implements Node & Timestamps {
  id: ID!
  name: String!
  isPublic: Boolean
  isVerified: Boolean
  users: [User]
  createdAt: DateTime
  updatedAt: DateTime
  members: [User!]
  challenges: [Challenge!]
  memberships: [CommunityMembership!]
  invitations: [CommunityInvitation!]
}

type CommunityMembership implements Node {
  id: ID!
  user: User!
  community: Community!
  isAdmin: Boolean!
  joinedAt: DateTime!
}

type CommunityInvitation implements Node & Timestamps {
  id: ID!
  community: Community!
  inviter: User!
  invitee: User!
  status: InvitationStatus!
  createdAt: DateTime!
  updatedAt: DateTime
  expiresAt: DateTime!
}

input CommunityCreateInput {
  name: String!
  isPublic: Boolean!
}

input CommunityUpdateInput {
  id: ID!
  name: String
}

interface Node {
  id: ID!
}

interface Timestamps {
  createdAt: DateTime
  updatedAt: DateTime
}

"""Date custom scalar type"""
scalar DateTime

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
}

"""
GraphQL Spec pagination information
https://relay.dev/graphql/connections.htm#sec-Connection-Types.Fields.PageInfo
"""
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!

  """First node of the edges"""
  startCursor: String

  """Last node of the edges"""
  endCursor: String
}

"""A user of the app"""
type User implements Node & Timestamps {
  id: ID!
  handle: String
  firstName: String
  lastName: String
  email: String
  password: String
  createdAt: DateTime
  updatedAt: DateTime

  """If they have any..."""
  friends: [User!]
  communities: [Community!]
  searchFriends(searchTerm: String): [User!]
  memberships: [CommunityMembership!]
  sentInvitations: [CommunityInvitation!]
  receivedInvitations: [CommunityInvitation!]
}

input UserUpdateInput {
  id: ID!
  firstName: String
  lastName: String
  handle: String
  email: String
}

type ValidEmailResponse {
  alreadyTaken: Boolean!
}

type CommunityEdge {
  cursor: String!
  node: Community!
}

type CommunityConnection {
  edges: [CommunityEdge!]
  pageInfo: PageInfo!
}

type Viewer {
  user: User
  communities(first: Int!, after: String): CommunityConnection!
  challenges(communityId: ID!): [Challenge!]
  challenge(challengeId: ID!): Challenge
}